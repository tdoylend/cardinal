 -  Ruby's `<<` operator and why I don't think it's a good idea for Cardinal
 -  What are helpful error messages and why are they hard?
 -  Redesigning the C API
 -  Garbage collector performance characteristics
 -  Error message formatting -- it's darn difficult
 -  Ways to minimize allocations -- and ways to make that easier on the
    programmer
 -  What should go in the standard libraries?
 -  Optimizations that won't make me pull my hair out
 -  Compiled bytecode, static analysis, and the exact semantics of `import`
 -  `field` versus implicit declarations
 -  Field inheritance, getters and setters -- are `getter` and `setter`
    keywords a feature worth having?
 -  What are fibers actually useful for?
 -  Async and ordering guarantees
 -  Why does avoiding recursion in the compiler matter so much?
 -  What constitutes pathological input and how much damage are we OK with it
    causing?
 -  What do we do about debuggers and IDEs?
 -  Are first-class functions any good?
 -  Is a `using` keyword any good? How would it work?
 -  Is it useful to be able to tack on additional static methods to a class,
    provided they don't access any static fields? What about regular methods?
 -  Why are all Lists not deques?
 -  Are tuples a good idea?
 -  Is a built-in `Either`/`Option`/`Maybe` type worth having?

